library IEEE;
use IEEE.std_logic_1164.all;

entity fsm is
port (clk, rst, init: in std_logic;
		Az, Bz, contz, Azero: in std_logic;
		mPH, mcont : out std_logic; -- Sinais dos mux
		cA, cB, ccont, cmult: out std_logic; -- sinais dos registradores
		srP, cPH, srPL, cPL: out std_logic
		);
end entity;

architecture behav of fsm is
type state is (s0, s1, s2, s3, s4, s5, s6);
signal current_state : state;
begin
	process(clk, rst)
	begin
		if (rst = '1') then 
			current_state <= s0;
		elsif (clk'event and clk = '1') then
			case state is
				when s0 =>
					if (init = '1') then
						current_state <= s1;
					else
						current_state <= s0;
					end if;	
				when s1 =>
					current_state <= s2;
				when s2 =>
					if (Az or Bz) then 
						current_state <= s6;
					else 
						current_state <= s3;
				when s3 =>
					if (contz = '1') then
						current_state <= s6;
					elsif (contz = '0' and azero = '1') then
						current_state <= s4;
					else
						current_state <= s5;
					end if;	
				when s4 =>
					current_state <= s5;
				when s5 =>
					current_state <= s3;
				when s6 =>
					current_state <= s6;
				end case;	
		end if;
	end process;
	process(current_state)
	begin
		case current_state is
			when s0 =>
				pronto <= '1';
				cA <= '0';
				cB <= '0';
				ccont <= '0';
				cmult <= '0';
			when s1 =>
				cA <= '1';
				cB <= '1';
				ccont <= '1';
				mcont <= '1';
				-- Falta registradores P
			when s2 =>
				cA <= '1';
				cB <= '1';
				ccont <= '1';
				mcont <= '1';
				-- Falta registradores P
			when s3 =>
				cA <= '0';
				cB <= '0';
				ccont <= '0';
			when s4
			when s5
			when s6
			end case;
	end process;		
end behav;

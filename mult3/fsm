library IEEE;
use IEEE.std_logic_1164.all;

entity fsm is
port(clk, rst, init: in std_logic;
		Bzero, Azero, contZero, PH0: in std_logic;
		shPH, cPH, shPL, cPL: out std_logic; -- sinais de PH e PL
		cB, cA, shA, cCont: out std_logic; -- sinais A,B,cont
		mPH, m1, m2, mff: out std_logic;
		cSaida: std_logic;
		pronto: out std_logic
		);
end entity;

architecture behav of fsm is 
type states is (s0, s1, s2, s3, s4, s5, s6);
signal current_state : states;

begin
	process (clk, rst)
	begin
		if (clk'event and clk = '1') then
			if (rst = '1') then
				current_state <= s0;
			else 
				case current_state is
					when s0 =>
						if init = '1' then
							current_state <= s1;
						else
							current_state <= s0;
						end if;
					when s1 =>
						current_state <= s2;
					when s2 =>
						if (Az = '1' or Bz = '1') then
							current_state <= s6;
						else 
							current_state <= s3;
						end if;
					when s3 =>
						if contZ = '0' then
							current_state <= s4;
						else 
							current_state <= s5;
						end if;
					when s4 =>
						current_state <= s5;
					when s5 =>
						current_state <= s3;
					when s6 =>
						current_state <= s0;	
				end case;	
			end if;			
		end if;
	end process;
	
	process(current_state)
	begin
		case current_state is
			when s0 =>
				pronto <= '1';
				cSaida <= '0';
			when s1 =>
				cA <= '1';
				sAA <= '0';
				cB <= '1';
				m2 <= '0';
				ccont <= '1';
				mPH <= '1';
				cPH <= '1';
			when s2 =>
				cA <= '0';
				cB <= '0';
				ccont <= '0';
				cPH <= '0';
				mPH <= '0';
				m2 <= '1';
				m1 <= '0';
				srPH <= '0';
			when s3 =>
				cPH <= '1';
				-- n sei se falta
			when s4 =>
				shPH <= '0';
				cPH <= '1';
				m1 = '0';
			when s5 =>
				ccont <= '1';
				m1 <= '1';
				m2 <= '1';
				if PH0 = '1' then
					cPL <= '1';
				else 
					cPL <= '0';
					shPL <= '0';
				end if;	
			when s6 =>
				cSaida <= '1';
		end case;	
	end process;
	
end behav;
